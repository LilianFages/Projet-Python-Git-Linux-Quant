from __future__ import annotations

import os
from datetime import datetime, timedelta
import pandas as pd
import numpy as np

# IMPORTANT: permet d'importer ton code quand cron run depuis ailleurs
import sys
REPO_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
sys.path.insert(0, REPO_ROOT)

from app.common.data_loader import load_price_data  # adapte si ton import diffère


def max_drawdown(equity: pd.Series) -> float:
    equity = equity.dropna()
    if equity.empty:
        return 0.0
    peak = equity.cummax()
    dd = (equity - peak) / peak
    return float(dd.min())


def realized_vol(returns: pd.Series, window: int = 20) -> float:
    r = returns.dropna()
    if len(r) < 2:
        return 0.0
    return float(r.tail(window).std() * np.sqrt(252))


def compute_asset_report(ticker: str, start: datetime, end: datetime) -> dict:
    df = load_price_data(ticker, start, end, interval="1d")
    if df is None or df.empty or "close" not in df.columns:
        return {
            "ticker": ticker,
            "status": "no_data",
        }

    df = df.sort_index()
    close = df["close"].astype(float)

    # Open/Close (jour le plus récent dans la fenêtre)
    last_row = df.iloc[-1]
    open_px = float(last_row["open"]) if "open" in df.columns and pd.notna(last_row.get("open")) else float(close.iloc[-1])
    close_px = float(close.iloc[-1])

    # Returns / vol / drawdown
    rets = close.pct_change()
    vol_20d = realized_vol(rets, window=20)

    # Max drawdown sur la période (sur equity proxy = close)
    mdd = max_drawdown(close)

    # Daily return (dernier jour)
    daily_ret = float(rets.iloc[-1]) if len(rets) >= 2 and pd.notna(rets.iloc[-1]) else 0.0

    return {
        "ticker": ticker,
        "status": "ok",
        "date": close.index[-1].date().isoformat(),
        "open": open_px,
        "close": close_px,
        "daily_return": daily_ret,
        "vol_20d_ann": vol_20d,
        "max_drawdown": mdd,
    }


def main():
    # Paramétrage via variables d’environnement (propre pour cron)
    tickers = os.environ.get("QP_REPORT_TICKERS", "AAPL,MSFT,SPY,BTC-USD").split(",")
    tickers = [t.strip() for t in tickers if t.strip()]

    # Fenêtre d’analyse (ex: 1 an)
    end = datetime.now()
    start = end - timedelta(days=int(os.environ.get("QP_REPORT_LOOKBACK_DAYS", "365")))

    rows = []
    for t in tickers:
        rows.append(compute_asset_report(t, start=start, end=end))

    report_df = pd.DataFrame(rows)

    # Output directories
    reports_dir = os.path.join(REPO_ROOT, "reports")
    os.makedirs(reports_dir, exist_ok=True)

    logs_dir = os.path.join(REPO_ROOT, "logs")
    os.makedirs(logs_dir, exist_ok=True)

    stamp = datetime.now().strftime("%Y-%m-%d")
    csv_path = os.path.join(reports_dir, f"daily_report_{stamp}.csv")
    md_path = os.path.join(reports_dir, f"daily_report_{stamp}.md")

    report_df.to_csv(csv_path, index=False)

    # Markdown simple (lisible dans GitHub)
    with open(md_path, "w", encoding="utf-8") as f:
        f.write(f"# Daily Report — {stamp}\n\n")
        f.write("Generated by cron on the Linux VM.\n\n")
        f.write(report_df.to_markdown(index=False))
        f.write("\n")

    print(f"[OK] Report written: {csv_path} and {md_path}")


if __name__ == "__main__":
    main()
